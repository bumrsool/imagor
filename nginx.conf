events {
    worker_connections 1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;
    
    # Logging
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';
    
    access_log /var/log/nginx/access.log main;
    error_log /var/log/nginx/error.log;
    
    # Upstream for imagor
    upstream imagor_backend {
        server imagor:8000;
        keepalive 32;
    }
    
    # Cache configuration
    proxy_cache_path /var/cache/nginx levels=1:2 keys_zone=imagor_cache:10m max_size=1g inactive=60m use_temp_path=off;
    
    server {
        listen 80;
        server_name localhost;
        
        # Health check endpoint
        location = /health {
            access_log off;
            return 200 "healthy\n";
            add_header Content-Type text/plain;
        }
        
        # Main imgix to imagor conversion
        location ~* ^/(?<image_path>.+)$ {
            # Set AWS-BUCKET based on hostname
            set $aws_bucket "";
            if ($host ~ "^mrsool-data-dev-images\.mrsool\.co$") {
                set $aws_bucket "mrsool-data-dev";
            }
            if ($host ~ "^mrsool-data-2-dev-images\.mrsool\.co$") {
                set $aws_bucket "mrsool-data-2-dev";
            }
            if ($host ~ "^mrsool-data-images\.mrsool\.co$") {
                set $aws_bucket "mrsool-data";
            }
            if ($host ~ "^mrsool-data-2-images\.mrsool\.co$") {
                set $aws_bucket "mrsool-data-2";
            }
            if ($host ~ "^mrsool-images\.mrsool\.co$") {
                set $aws_bucket "mrsool-business";
            }
            # Default fallback
            if ($aws_bucket = "") {
                set $aws_bucket "mrsool-data-dev";
            }
            
            # Extract imgix parameters
            set $width $arg_w;
            set $height $arg_h;
            # Handle hyphenated parameters - nginx converts max-w to max_w in args
            set $max_width "";
            set $max_height "";
            if ($args ~ "max-w=([^&]+)") {
                set $max_width $1;
            }
            if ($args ~ "max-h=([^&]+)") {
                set $max_height $1;
            }
            set $quality $arg_q;
            set $format $arg_fm;
            set $fit $arg_fit;
            set $crop $arg_crop;
            set $auto $arg_auto;
            set $brightness $arg_bri;
            set $contrast $arg_con;
            set $saturation $arg_sat;
            set $blur $arg_blur;
            set $sharpen $arg_sharpen;
            set $greyscale $arg_greyscale;
            set $monochrome $arg_monochrome;
            
            # Initialize filters string
            set $filters '';
            
            # Handle dimensions with proper fallback logic
            # If explicit width/height provided, use them; otherwise use max dimensions; otherwise use 0
            if ($width = "") {
                set $width $max_width;
            }
            if ($width = "") {
                set $width "0";
            }
            
            if ($height = "") {
                set $height $max_height;
            }
            if ($height = "") {
                set $height "0";
            }
            
            # Handle fit parameter (imgix fit modes to thumbor)
            if ($fit = "crop") {
                set $filters "${filters}filters:crop(0,0,${width},${height})";
            }
            if ($fit = "fill") {
                set $filters "${filters}filters:fill(white)";
            }
            if ($fit = "scale") {
                set $filters "${filters}filters:no_upscale()";
            }
            if ($fit = "clamp") {
                set $filters "${filters}filters:no_upscale()";
            }
            if ($fit = "clip") {
                set $use_fit_in "true";
            }
            
            # Handle quality/compression
            if ($quality != "") {
                set $filters "${filters}filters:quality(${quality})";
            }
            if ($quality = "") {
                set $filters "${filters}filters:quality(40)";
            }
            if ($auto = "compress") {
                set $filters "${filters}filters:quality(80)";
            }
            
            # Handle format conversion
            if ($format = "webp") {
                set $filters "${filters}filters:format(webp)";
            }
            if ($format = "png") {
                set $filters "${filters}filters:format(png)";
            }
            if ($format = "jpg") {
                set $filters "${filters}filters:format(jpeg)";
            }
            if ($format = "jpeg") {
                set $filters "${filters}filters:format(jpeg)";
            }
            
            # Handle auto parameter
            if ($auto = "format") {
                set $filters "${filters}filters:format(webp)";
            }
            
            # Handle brightness
            if ($brightness != "") {
                set $filters "${filters}filters:brightness(${brightness})";
            }
            
            # Handle contrast
            if ($contrast != "") {
                set $filters "${filters}filters:contrast(${contrast})";
            }
            
            # Handle saturation
            if ($saturation != "") {
                set $filters "${filters}filters:saturation(${saturation})";
            }
            
            # Handle blur
            if ($blur != "") {
                set $filters "${filters}filters:blur(${blur})";
            }
            
            # Handle sharpen
            if ($sharpen != "") {
                set $filters "${filters}filters:sharpen(${sharpen})";
            }
            
            # Handle monochrome - apply greyscale for all monochrome values
            if ($monochrome != "") {
                set $filters "${filters}filters:grayscale()";
            }
            
            # Construct imagor URL
            if ($use_fit_in = "true") {
                set $imagor_url "/unsafe/fit-in/${width}x${height}";
            }
            if ($use_fit_in != "true") {
                set $imagor_url "/unsafe/${width}x${height}";
            }
            if ($filters != "") {
                set $imagor_url "${imagor_url}/${filters}";
            }
            set $imagor_url "${imagor_url}/${image_path}";
            
            # Enable caching
            proxy_cache imagor_cache;
            proxy_cache_valid 200 1h;
            proxy_cache_valid 404 1m;
            proxy_cache_use_stale error timeout updating http_500 http_502 http_503 http_504;
            proxy_cache_lock on;
            
            # Proxy to imagor
            proxy_pass http://imagor_backend$imagor_url;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header AWS-BUCKET $aws_bucket;
            
            # Proxy timeout settings - Increased for large PNG processing
            proxy_connect_timeout 10s;
            proxy_send_timeout 150s;
            proxy_read_timeout 150s;
            
            # Cache headers
            add_header X-Cache-Status $upstream_cache_status;
            expires 1h;
            add_header Cache-Control "public, immutable";
        }
        
        # Fallback for non-image requests
        location / {
            return 404 "Not found";
        }
    }
}
